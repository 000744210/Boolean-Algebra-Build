<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boolean Expression To K-Map</title>
    <meta name="description" content="Boolean Algebra expression simplifier & solver. Detailed steps, Logic circuits, K-Map, Truth table, & Quizes. All in one calculator." />
    <base href="/" />
    <link href="css/bootstrap/bootstrap.min.css" rel="stylesheet" />
    <link href="css/site.css" rel="stylesheet" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-150354135-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'UA-150354135-1');
    </script>
    <script data-ad-client="ca-pub-3710933901766821" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>
<body>
    <div id="ad-manipulator" style=" transform: translateX(-100000px); height: 0;">

    </div>
    <app>
        <canvas id="loaderCanvas" style="width:200px;height:200px;margin-left:auto;margin-right:auto;display:block"></canvas>
        <h2 style="text-align:center;margin-left:auto;margin-right:auto;display:block">Loading...</h2>
        <div class="main-web-width" style="text-align:center;border: 1px solid #acacac;border-radius: 11px;margin-top:100px">
            <h3 class="center">This may take awhile...</h3>
            <p>The website is currently getting the required resources.</p>
            <p>If it takes longer than 30 seconds then please refresh unless you have slow internet.</p>

        </div>
        <script>

            function mapNodes(nodeArray) {
                var output = null;
                var refs = new Map();

                nodeArray.forEach(function (obj) {
                    refs.set(obj.guid, obj)
                })

                nodeArray.forEach(function (obj) {
                    if (obj.input) {
                        obj.input = refs.get(obj.input.guid)
                    }
                    if (obj.leftInput) {
                        obj.leftInput = refs.get(obj.leftInput.guid)
                    }
                    if (obj.rightInput) {
                        obj.rightInput = refs.get(obj.rightInput.guid)
                    }
                    if (obj.output) {
                        obj.output = refs.get(obj.output.guid)
                    }
                    if (obj.circutType == 'OUTPUT') {
                        output = obj
                    }
                })
                return output;
            }

            function getSizeOfNodes(node) {
                return getSizeOfNodesHelper(node, 0);
            }

            function getSizeOfNodesHelper(node, score) {
                if (node.leftInput) {
                    score += getSizeOfNodesHelper(node.leftInput, 0)
                }
                if (node.rightInput) {
                    score += getSizeOfNodesHelper(node.rightInput, 0)
                }
                if (node.input) {
                    score += getSizeOfNodesHelper(node.input, 0)
                }
                if (node.circutType == "INPUT") {
                    score += 1
                }

                return score;
            }

            var depthSize = 80;
            var ySize = 25;
            var orPath = new Path2D('M24.09375 5l2 2.4375S31.75 14.437549 31.75 25s-5.65625 17.5625-5.65625 17.5625l-2 2.4375H41.25c2.408076.000001 7.689699.024514 13.625-2.40625s12.536536-7.343266 17.6875-16.875L71.25 25l1.3125-.71875C62.259387 5.21559 46.006574 5 41.25 5H24.09375zm5.875 3H41.25c4.684173 0 18.28685-.130207 27.96875 17C64.451964 33.429075 58.697469 37.68391 53.5 39.8125 48.139339 42.007924 43.658075 42.000001 41.25 42H30c1.873588-3.108434 4.75-9.04935 4.75-17 0-7.973354-2.908531-13.900185-4.78125-17z');

            var andPath = new Path2D('M30 5V45H50.47619c11.267908 0 20-9.000045 20-20s-8.732091-20-20-20H30zm2.857143 2.857143H50.47619c9.760663 0 16.666667 7.639955 16.666667 17.142857 0 9.502902-7.382195 17.142857-17.142857 17.142857H32.857143V7.857143z');

            var notPath = new Path2D('M 28.9688 2.5938 v 44.8125 l 2.1563 -1.0625 l 41.0313 -20 v -1.3748 L 68.022 24.969 A 1 1 0 0 0 77.193 23.935 A 1 1 0 0 0 68.011 24.966 l 3.741 -1.591 z m 3 4.8125 L 68.0938 25 l -36.125 17.5938 V 7.4063 z');

            function getLogicGateDiagram(node) {
                console.log(node)


                var canvas = document.createElement("canvas")
                canvas.width = 4000
                canvas.height = 12000

                var ctx = canvas.getContext("2d");

                /*ctx.save()

                var grd = ctx.createLinearGradient(0, 0, 4000, 0);
                grd.addColorStop(0, "red");
                grd.addColorStop(1, "white");

                // Fill with gradient
                ctx.fillStyle = grd;
                ctx.fillRect(0, 0, canvas.width,canvas.height);

                ctx.restore();*/
                ctx.translate(canvas.width - 100, canvas.height / 2);
                ctx.font = '30px Arial';
                node = mapNodes(node)

                positionNodes(node.input, 0, 0);
                // This is very weird but required. It increases the percision every time.
                moveNodesCloser(node.input);
                moveNodesCloser(node.input);
                moveNodesCloser(node.input);
                moveNodesCloser(node.input);
                moveNodesCloser(node.input);


                centerNodes(node.input);
                centerNodes(node.input);
                centerNodes(node.input);
                centerNodes(node.input);
                centerNodes(node.input);

                drawLogicGates(node.input, ctx)

                //drawTree(node.input, 0, 0, ctx);


                var bounds = contextBoundingBox(node.input)
                var newCanvas = cropCanvas(canvas, canvas.width + bounds.minX - 100, canvas.height / 2 + bounds.minY - 25, bounds.w + 100, bounds.h + 100)
                return newCanvas

            }

            function cropCanvas(canvas, x, y, width, height) {
                // create a temp canvas
                const newCanvas = document.createElement('canvas');
                // set its dimensions
                newCanvas.width = width;
                newCanvas.height = height;
                // draw the canvas in the new resized temp canvas
                newCanvas.getContext('2d').drawImage(canvas, x, y, width, height, 0, 0, width, height);
                return newCanvas
            };

            function contextBoundingBox(node, boundry) {
                if (boundry === undefined) {
                    boundry = { minX: node.x, minY: node.y, maxX: node.x, maxY: node.y };
                }
                // 0
                if (node.x > boundry.maxX) {
                    boundry.maxX = node.x
                }

                if (node.y > boundry.maxY) {
                    boundry.maxY = node.y
                }

                if (node.x < boundry.minX) {
                    boundry.minX = node.x
                }

                if (node.y < boundry.minY) {
                    boundry.minY = node.y
                }

                if (node.leftInput && node.rightInput) {
                    contextBoundingBox(node.leftInput, boundry)
                    contextBoundingBox(node.rightInput, boundry)
                }
                if (node.input) {
                    contextBoundingBox(node.input, boundry)
                }

                boundry.w = boundry.maxX - boundry.minX
                boundry.h = boundry.maxY - boundry.minY
                return boundry
            }

            function positionNodes(node, depth, y) {

                if (node.leftInput && node.rightInput) {
                    var leftSize = getSizeOfNodes(node.leftInput) * ySize;
                    var rightSize = getSizeOfNodes(node.rightInput) * ySize;

                    //ctx.save();
                    console.log(node.circutType)
                    if (node.circutType == 'OR') {
                        node.x = -(depth * depthSize)
                        node.y = y;
                        //ctx.translate(-(depth*depthSize), y);
                        //orPath.moveTo(-(depth*depthSize),y)
                        //ctx.fill(orPath);
                    } else if (node.circutType == 'AND') {
                        node.x = -(depth * depthSize)
                        node.y = y;
                        //ctx.translate(-(depth*depthSize), y);
                        //ctx.fill(andPath)
                    }
                    //ctx.restore();
                    //ctx.fillText(node.circutType,-(depth*depthSize),y)

                    //console.log(leftSize)
                    //ctx.fillText(node.leftInput.circutType,-(depth*50),y-leftSize)
                    //ctx.fillText(node.leftInput.circutType,-(depth*50),y+leftSize)
                    positionNodes(node.leftInput, depth + 1, y - (leftSize))
                    positionNodes(node.rightInput, depth + 1, y + (rightSize));
                    //drawBetweenNodes(node.leftInput,node,"leftInput")
                    //drawBetweenNodes(node.rightInput,node,"rightInput")

                } else if (node.input) {
                    var size = getSizeOfNodes(node.input) * ySize;
                    //ctx.save();
                    if (node.circutType == 'NOT') {
                        node.x = -(depth * depthSize)
                        node.y = y;
                        //ctx.translate(-(depth*depthSize), y);
                        //ctx.fill(notPath)
                    }
                    //ctx.restore();
                    positionNodes(node.input, depth + 1, y)
                    //drawBetweenNodes(node.input,node,"input")
                } else if (node.circutType == 'INPUT') {
                    node.x = -(depth * depthSize)
                    node.y = y;
                    //ctx.fillText(node.inputVaraible,-(depth*depthSize)+40,y+35)
                    //ctx.beginPath();
                    //ctx.arc(-(depth*depthSize)+50, y+25, 20, 0, 2 * Math.PI);
                    //ctx.lineWidth = 3;
                    //ctx.stroke();

                }

            }

            function drawLogicGates(node, ctx) {
                ctx.save();
                if (node.circutType == "AND") {
                    ctx.translate(node.x, node.y);
                    ctx.fill(andPath)
                }
                if (node.circutType == "OR") {
                    ctx.translate(node.x, node.y);
                    ctx.fill(orPath)
                }
                if (node.circutType == "NOT") {
                    ctx.translate(node.x, node.y);
                    ctx.fill(notPath)
                }
                if (node.circutType == "INPUT") {
                    ctx.fillText(node.inputVaraible, node.x + 40, node.y + 35)
                    ctx.beginPath();
                    ctx.arc(node.x + 50, node.y + 25, 20, 0, 2 * Math.PI);
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
                ctx.restore()
                if (node.leftInput) {
                    drawLogicGates(node.leftInput, ctx)
                    drawBetweenNodes(node.leftInput, node, "leftInput",ctx)
                }
                if (node.rightInput) {
                    drawLogicGates(node.rightInput, ctx)
                    drawBetweenNodes(node.rightInput, node, "rightInput",ctx)
                }
                if (node.input) {
                    drawLogicGates(node.input, ctx)
                    drawBetweenNodes(node.input, node, "input",ctx)
                }
            }

            function drawLine(x1, y1, x2, y2, ctx) {
                var distanceBetweenX = Math.abs(x1 - x2);
                ctx.beginPath();
                ctx.moveTo(x1, y1)
                ctx.lineTo(x1 + (distanceBetweenX / 2), y1)
                ctx.lineTo(x1 + (distanceBetweenX / 2), y2)
                ctx.lineTo(x2, y2)
                ctx.lineWidth = 3;
                ctx.stroke();
            }

            function getMinAndMax(node) {
                var min = 0;
                var max = 0;

                var leftestNode = node
                while (leftestNode.leftInput || leftestNode.input) {
                    if (leftestNode.leftInput) leftestNode = leftestNode.leftInput;
                    else if (leftestNode.input) leftestNode = leftestNode.input;
                }
                min = leftestNode.y

                var righestNode = node

                while (righestNode.rightInput || righestNode.input) {
                    if (righestNode.rightInput) righestNode = righestNode.rightInput;
                    else if (righestNode.input) righestNode = righestNode.input;

                }
                max = righestNode.y

                return { min: min, max: max };
            }
            function moveNodesCloser(node) {
                if (node.leftInput && node.rightInput) {
                    var left = getMinAndMax(node.leftInput)
                    var right = getMinAndMax(node.rightInput)
                    var distance = right.min - left.max;
                    console.log(right.min - left.max)
                    moveNodes(node.rightInput, distance - ySize * 2)
                    moveNodesCloser(node.leftInput)
                    moveNodesCloser(node.rightInput)
                } else if (node.input) {
                    moveNodesCloser(node.input)
                }
            }

            function moveNodes(node, changedY) {
                node.y = node.y - changedY
                if (node.leftInput && node.rightInput) {
                    moveNodes(node.leftInput, changedY)
                    moveNodes(node.rightInput, changedY)
                } else if (node.input) {
                    moveNodes(node.input, changedY)
                }
            }

            function centerNodes(node) {
                if (node.leftInput && node.rightInput) {
                    var leftY = node.leftInput.y
                    var rightY = node.rightInput.y
                    var difference = leftY - rightY
                    node.y = (leftY + rightY) / 2
                    centerNodes(node.leftInput)
                    centerNodes(node.rightInput)
                } else if (node.input) {
                    node.y = node.input.y;
                    centerNodes(node.input)
                }

            }
            /**
                 Due to the ugly nature of logic gate images, drawing it perfectly requires a handwritten list of line positions.
                We manually adjust the positions of each line.
            **/
            function drawBetweenNodes(inputNode, outputNode, inputName, ctx) {

                if (inputNode.circutType == 'INPUT' && outputNode.circutType == "NOT") {
                    drawLine(inputNode.x + 70, inputNode.y + 25, outputNode.x + 30, outputNode.y + 25, ctx)
                } else if (inputNode.circutType == 'INPUT' && outputNode.circutType == "AND") {
                    if (inputName == "leftInput") {
                        drawLine(inputNode.x + 70, inputNode.y + 25, outputNode.x + 30, outputNode.y + 18, ctx)
                    } else if (inputName == "rightInput") {
                        drawLine(inputNode.x + 70, inputNode.y + 25, outputNode.x + 30, outputNode.y + 32, ctx)
                    }
                } else if (inputNode.circutType == 'NOT' && outputNode.circutType == "AND") {
                    if (inputName == "leftInput") {
                        drawLine(inputNode.x + 70, inputNode.y + 25, outputNode.x + 30, outputNode.y + 18, ctx)
                    } else if (inputName == "rightInput") {
                        drawLine(inputNode.x + 70, inputNode.y + 25, outputNode.x + 30, outputNode.y + 32, ctx)
                    }
                } else if (inputNode.circutType == 'AND' && outputNode.circutType == "AND") {
                    if (inputName == "leftInput") {
                        drawLine(inputNode.x + 70, inputNode.y + 25, outputNode.x + 30, outputNode.y + 18, ctx)
                    } else if (inputName == "rightInput") {
                        drawLine(inputNode.x + 70, inputNode.y + 25, outputNode.x + 30, outputNode.y + 32, ctx)
                    }
                } else if (inputNode.circutType == 'AND' && outputNode.circutType == "OR") {
                    if (inputName == "leftInput") {
                        drawLine(inputNode.x + 70, inputNode.y + 25, outputNode.x + 31, outputNode.y + 18, ctx)
                    } else if (inputName == "rightInput") {
                        drawLine(inputNode.x + 70, inputNode.y + 25, outputNode.x + 31, outputNode.y + 32, ctx)
                    }
                } else if (inputNode.circutType == 'INPUT' && outputNode.circutType == "OR") {
                    if (inputName == "leftInput") {
                        drawLine(inputNode.x + 70, inputNode.y + 25, outputNode.x + 31, outputNode.y + 18, ctx)
                    } else if (inputName == "rightInput") {
                        drawLine(inputNode.x + 70, inputNode.y + 25, outputNode.x + 31, outputNode.y + 32, ctx)
                    }
                } else if (inputNode.circutType == 'NOT' && outputNode.circutType == "OR") {
                    if (inputName == "leftInput") {
                        drawLine(inputNode.x + 70, inputNode.y + 25, outputNode.x + 31, outputNode.y + 18, ctx)
                    } else if (inputName == "rightInput") {
                        drawLine(inputNode.x + 70, inputNode.y + 25, outputNode.x + 31, outputNode.y + 32, ctx)
                    }
                } else if (inputNode.circutType == 'OR' && outputNode.circutType == "NOT") {
                    drawLine(inputNode.x + 70, inputNode.y + 25, outputNode.x + 31, outputNode.y + 25, ctx)
                } else if (inputNode.circutType == 'OR' && outputNode.circutType == "OR") {
                    if (inputName == "leftInput") {
                        drawLine(inputNode.x + 70, inputNode.y + 25, outputNode.x + 31, outputNode.y + 18, ctx)
                    } else if (inputName == "rightInput") {
                        drawLine(inputNode.x + 70, inputNode.y + 25, outputNode.x + 31, outputNode.y + 32, ctx)
                    }
                } else if (inputNode.circutType == 'AND' && outputNode.circutType == "NOT") {
                    drawLine(inputNode.x + 70, inputNode.y + 25, outputNode.x + 31, outputNode.y + 25, ctx)
                } else if (inputNode.circutType == 'OR' && outputNode.circutType == "AND") {
                    if (inputName == "leftInput") {
                        drawLine(inputNode.x + 70, inputNode.y + 25, outputNode.x + 31, outputNode.y + 18, ctx)
                    } else if (inputName == "rightInput") {
                        drawLine(inputNode.x + 70, inputNode.y + 25, outputNode.x + 31, outputNode.y + 32, ctx)
                    }
                } else {
                    if (inputName == "leftInput") {
                        drawLine(inputNode.x + 70, inputNode.y + 25, outputNode.x + 31, outputNode.y + 18, ctx)
                    } else if (inputName == "rightInput") {
                        drawLine(inputNode.x + 70, inputNode.y + 25, outputNode.x + 31, outputNode.y + 32, ctx)
                    } else if (inputName == "input") {
                        drawLine(inputNode.x + 70, inputNode.y + 25, outputNode.x + 31, outputNode.y + 25, ctx)
                    }
                }

            }


            function initCanvasDraw() {
                /** https://www.dwitter.net/d/1385 **/
                /** Ported to normal javascript **/

                var factor = .4; // scale it down to fit on a smaller canvas.
                var canvas = document.getElementById("loaderCanvas");
                var context = canvas.getContext("2d");
                canvas.width = 500;
                canvas.height = 500;
                var start = Date.now();
                context.scale(factor, factor)
                context.strokeStyle = "Black";
                setInterval(function () {
                    // cleaned and slightly modified version of the original.
                    context.clearRect(0, 0, canvas.width / factor, canvas.height / factor);
                    time = (Date.now() - start) / 1000;
                    for (i = 3; i++ < 11;) {
                        a = i * Math.sin(time) / 4;
                        context.beginPath();
                        context.arc(250 / factor, 250 / factor, 40 * i, Math.min(time + a, time + 3 * a), Math.max(time + a, time + 3 * a));
                        context.lineWidth = i * i / 5;
                        context.stroke();
                    }
                }, 1000 / 60);

            }
            initCanvasDraw();
        </script>
    </app>
    <div class="main-web-width" style="text-align:center;border: 1px solid #acacac;border-radius: 11px;margin-top:10px">
        <h3 class="center">Want to practice or learn SQL?</h3>
        <p>Try out my other site. <a href="https://www.sql-practice.com/" target="_blank">https://www.sql-practice.com/</a></p>
        <p>Solve practice querys using an online SQL terminal.</p>
    </div>
    <div class="main-web-width" style="text-align:center;border: 1px solid #acacac;border-radius: 11px;margin-top:10px">
        <h3 class="center">Help</h3>
        <p>Try out my other site. <a href="https://www.compareminds.com" target="_blank">https://www.compareminds.com</a></p>
        <p>I need help collecting statistics about the games on the site.</p>
    </div>
    <script type="text/javascript">

        atOptionsBottomList = [
            {
                'key': 'aa401f6589ea8ced1b4f53462a4f797c',
                'format': 'iframe',
                'height': 250,
                'width': 300,
                'min-width': 320,
                'params': {}
            },
            {
                'key': 'ebfe6c66c8a7ba4ddd8a045ac0f276ce',
                'format': 'iframe',
                'height': 50,
                'width': 320,
                'min-width': 350,
                'params': {}
            },
            {
                'key': '7ddcc2f0513abf04bc423459526d3ecc',
                'format': 'iframe',
                'height': 60,
                'width': 468,
                'min-width': 500,
                'params': {}
            },
            {
                'key': '6ce9b4b94bc8b7b7bbe3169ed36d81e4',
                'format': 'iframe',
                'height': 90,
                'width': 728,
                'min-width': 750,
                'params': {}
            }
        ]

        socialBarUrl = "//pl16122563.gatetotrustednetwork.com/22/db/2f/22db2febb1be93c17125454a25a94f42.js"

        atOptionsBottomList = atOptionsBottomList.filter(function (a) { return window.innerWidth >= a['min-width'] })
        atOptions = atOptionsBottomList[Math.floor(Math.random() * atOptionsBottomList.length)];

    </script>
    <script type="blazor-boot">
    </script>
    <script src="_framework/blazor.webassembly.js"></script>
    <link rel="stylesheet" href="/mq/mathquill.css" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
    <script src="/mq/mathquill.js"></script>
    <script>
        function inputBuilder(state) {

            var charSet = ['A', 'B', 'C', 'D']

            var split = state.split('-')
            var charSetSize = parseInt(split[0])
            $("#CharSetSize").val(charSetSize)
            charSet = charSet.slice(0, charSetSize)
            var grayCodes = split[1].split('_')
            var input = new KMapInput(charSet)
            grayCodes.forEach((code) => {
                input.loadGrayCode(code)
            })
            return input;
        };

        var MQ = MathQuill.getInterface(2);
        function connectHoverEvents(classes) {
            for (let i = 0; i < classes.length; i++) {
                if (document.getElementsByClassName(classes[i] + "_event").length > 0) {
                    document.getElementsByClassName(classes[i] + "_event")[0].style["cursor"] = 'pointer'
                    document.getElementsByClassName(classes[i] + "_event")[0].addEventListener("mouseover", function () {
                        var classList = document.querySelectorAll('* [class*= "' + classes[i] + '"]:not(.step-head)');
                        Array.from(classList).forEach(function (e) {
                            if (e["style"]) {
                                e.style["color"] = "red";
                                e.style['border-top-color'] = "red";
                            }
                        });
                    });

                    document.getElementsByClassName(classes[i] + "_event")[0].addEventListener("mouseout", function () {
                        var classList = document.querySelectorAll('* [class*= "' + classes[i] + '"]:not(.step-head)');
                        Array.from(classList).forEach(function (e) {
                            if (e["style"]) {
                                e.style["color"] = "#212529";
                                e.style['border-top-color'] = "#212529";
                            }
                        });
                    });
                }
            }
        }
        function getParameterByName(name, url) {
            if (!url) url = window.location.href;
            name = name.replace(/[\[\]]/g, '\\$&');
            var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'),
                results = regex.exec(url);
            if (!results) return null;
            if (!results[2]) return '';
            return decodeURIComponent(results[2]);
        }

        function getCookie(cname) {
            var name = cname + "=";
            var decodedCookie = decodeURIComponent(document.cookie);
            var ca = decodedCookie.split(';');
            for (var i = 0; i < ca.length; i++) {
                var c = ca[i];
                while (c.charAt(0) == ' ') {
                    c = c.substring(1);
                }
                if (c.indexOf(name) == 0) {
                    return c.substring(name.length, c.length);
                }
            }
            return "";
        }

        var isFirstVisit = true;
        var answerMathField = null;
        var inputbox = null;
        var outputbox = null;
        window.JsFunc = {
            KMapPageInit: function () {
                if (inputbox) inputbox.remove();
                var charSet = ['A', 'B', 'C', 'D'];

                if (getParameterByName('q')) {
                    inputbox = inputBuilder(getParameterByName('q'))
                    charSet = inputbox.charSet;
                } else {

                    inputbox = new KMapInput(charSet)
                }
                var inputcanvas = document.getElementById("kmapInput")
                inputbox.initAnimation(inputcanvas)
                inputbox.onInput = function (tiles) {

                    DotNet.invokeMethodAsync("Boolean-Algebra", "SolveKmap", {
                        width: inputbox.slotsWidth,
                        height: inputbox.slotsHeight,
                        tiles: tiles,
                        charSet: charSet
                    }).then(function (result) {
                        if (outputbox) {
                            outputbox.remove();
                            outputbox = new KMap(charSet)
                        }
                        if (outputbox == null) outputbox = new KMap(charSet);

                        result.kmapSolution.forEach((rect) => {
                            outputbox.addRectangle(rect)
                        })

                        var newCanvas = getLogicGateDiagram(result.gateNodes)
                        newCanvas.style["maxWidth"] = "600px";

                        document.getElementById("logicgateLocation").innerHTML = "";
                        document.getElementById("logicgateLocation").appendChild(newCanvas)

                        outputbox.initAnimation(document.getElementById("kmapOutput"))
                        $("#kmapFullContainer").css("display", "block")
                        //$("#truthtableContainer").css("display", "block")
                        document.getElementById("kmapAlgebraAnswer").innerHTML = result.algebraLatex
                        document.getElementById("truthtableLocation").innerHTML = result.truthTableHtml
                        JsFunc.RenderLatex();


                    })

                }
                if (getParameterByName('q')) {
                    inputbox.forceInput();
                }

            },
            CharSetSizeChange: function () {
                var newSize = Math.min(Math.max(document.getElementById("CharSetSize").value, 1), 4);
                var charSet = ['A', 'B', 'C', 'D']
                var charSet = charSet.slice(0, newSize)
                document.getElementById("kmapAlgebraAnswer").innerHTML = "";
                document.getElementById("truthtableLocation").innerHTML = "";
                $("#kmapFullContainer").css("display", "none")
                //$("#truthtableContainer").css("display", "none")
                inputbox.remove();
                var inputcanvas = document.getElementById("kmapInput")
                inputbox = new KMapInput(charSet);
                inputbox.initAnimation(inputcanvas)
                if (outputbox) outputbox.remove();
                outputbox = null;
                inputbox.onInput = (tiles) => {
                    DotNet.invokeMethodAsync("Boolean-Algebra", "SolveKmap", {
                        width: inputbox.slotsWidth,
                        height: inputbox.slotsHeight,
                        tiles: tiles,
                        charSet: charSet
                    }).then(function (result) {
                        if (outputbox) {
                            outputbox.remove();
                            outputbox = new KMap(charSet)
                        }
                        if (outputbox == null) outputbox = new KMap(charSet);

                        result.kmapSolution.forEach((rect) => {
                            outputbox.addRectangle(rect)
                        })

                        var newCanvas = getLogicGateDiagram(result.gateNodes)
                        newCanvas.style["maxWidth"] = "600px";

                        document.getElementById("logicgateLocation").innerHTML = "";
                        document.getElementById("logicgateLocation").appendChild(newCanvas)

                        outputbox.initAnimation(document.getElementById("kmapOutput"))
                        $("#kmapFullContainer").css("display", "block")
                        //$("#truthtableContainer").css("display", "block")
                        document.getElementById("kmapAlgebraAnswer").innerHTML = result.algebraLatex
                        document.getElementById("truthtableLocation").innerHTML = result.truthTableHtml
                        JsFunc.RenderLatex();


                    })
                }
            },
            OnPageFirstLoadGlobal: function () {

            },
            OnPageLoadGlobal: function () {
                var isBot = /bot|googlebot|crawler|spider|robot|crawling/i.test(navigator.userAgent)
                if (/*typeof (window.google_jobrunner) !== "undefined" &&*/ !isBot) {
                    //console.log("RUNNING GOOGLE ADS")
                    if (document.getElementById("ad-spot") && document.getElementById("ad-spot").children.length == 0) {
                        var div = document.createElement("div")
                        var script = document.createElement("script");
                        script.async = true;
                        script.src = "https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js";

                        var ins = document.createElement("ins");
                        ins.className = "adsbygoogle";
                        ins.style = "display:block;"
                        ins.setAttribute('data-ad-client', 'ca-pub-3710933901766821');
                        ins.setAttribute('data-ad-slot', '9749452572');
                        ins.setAttribute('data-ad-format', 'auto');
                        ins.setAttribute('data-full-width-responsive', 'true');


                        var script2 = document.createElement("script");
                        script2.text = `(adsbygoogle = window.adsbygoogle || []).push({});`;

                        div.appendChild(script);
                        div.appendChild(ins);
                        div.appendChild(script2);
                        document.getElementById("ad-spot").appendChild(div)

                    }
                    if (document.getElementById("ad-spot2") && document.getElementById("ad-spot2").children.length == 0 && window.innerWidth > 1180) {
                        var div = document.createElement("div")
                        var script = document.createElement("script");
                        script.async = true;
                        script.src = "https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js";

                        var ins = document.createElement("ins");
                        ins.className = "adsbygoogle";
                        ins.style = "display:block;"
                        ins.setAttribute('data-ad-client', 'ca-pub-3710933901766821');
                        ins.setAttribute('data-ad-slot', '1148714309');
                        ins.setAttribute('data-ad-format', 'auto');
                        ins.setAttribute('data-full-width-responsive', 'true');


                        var script2 = document.createElement("script");
                        script2.text = `(adsbygoogle = window.adsbygoogle || []).push({});`;

                        div.appendChild(script);
                        div.appendChild(ins);
                        div.appendChild(script2);
                        document.getElementById("ad-spot2").appendChild(div)
                    }
                }
                setTimeout(function () {
                    if (true || (typeof (window.google_jobrunner) === "undefined" && document.getElementById("nord-ad-spot").children.length == 0)) {
                        //document.getElementById("nord-ad-spot").innerHTML = `<div id="nord-ad" class="nord-ad-outter"><a class="nord-ad" href="https://go.nordvpn.net/aff_c?offer_id=15&aff_id=52104&url_id=902" target="_blank"><div class="nord-ad-div"></div><img src="https://go.nordvpn.net/aff_i?file_id=350&aff_id=52104&offer_id=15"></a></div>`;
                        //document.getElementById("nord-ad-spot").innerHTML = `<div id="nord-ad" class="nord-ad-outter"><a href="/redir.html" target="_top"><img src="/img/vpn.jpg" alt="" title="" width="300" height="250" /></a></div>`
                        /*REAL AD*///document.getElementById("ad-spot-afil").innerHTML = `<div id="nord-ad" class="affiliate1"><a href="/redir.html" target="_blank"><img src="/img/vpnfoot.jpg" alt="" title="" style="max-width:100%" /></a></div>`
                    }
                }, 500)


            },
            BooleanAlgebraPageInit: function () {

                var answerSpan = document.getElementById('question');
                answerMathField = MQ.MathField(answerSpan);
                setTimeout(function () {
                    var q = getParameterByName("q");
                    if (q != null && isFirstVisit) {
                        q = window.atob(q);
                        answerMathField.latex(q.replace(/{/g, "\\overline{"))
                        document.getElementById("submit-btn").click();
                    }
                    /*
                    var seenAd = getCookie("seenAd")

                    var isBot = /bot|googlebot|crawler|spider|robot|crawling/i.test(navigator.userAgent)

                    if (isFirstVisit && seenAd == "" && !isBot) {
                    try {
                    if (Math.random() <= 1) {
                    var script = document.createElement("script");
                    script.src = socialBarUrl;
                    document.body.appendChild(script)
                    var d = new Date();
                    document.cookie = "seenAd=true; expires=Thu, 18 Dec " + (d.getFullYear() + 10) + " 12:00:00 UTC";
                    } else if (atOptions) {
                    var ad = document.getElementById("nord-ad");
                    var script = document.createElement("script");

                    script.src = "https://www.displaynetworkcontent.com/" + atOptions.key + "/invoke.js";
                    ad.appendChild(script)
                    *//*ad.addEventListener("click", function () {
                    window.open("https://go.nordvpn.net/aff_c?offer_id=15&aff_id=52104&url_id=902");
                    })
                    setTimeout(function () {

                    ad.className = ad.className + " slide"

                    }, 3000)*//*

                    setTimeout(function () {

                    ad.className = ad.className + " wiggler"

                    }, 20000)
                    }
                    } catch (e) {
                    console.log(e);
                    }
                    }*/
                    isFirstVisit = false;
                }, 1000)

            },
            BooleanAlgebraSolveClick: function () {
                var latex = answerMathField.latex();

                DotNet.invokeMethodAsync("Boolean-Algebra", "SolveLatex", latex)

            },
            GetQuestion: function () {
                return answerMathField.latex();
            },
            RenderQuizInterface: function () {
                MQ.StaticMath(document.getElementById("quizQuestion"))

                for (var ele of document.getElementsByClassName("quiz-button-latex")) {
                    MQ.StaticMath(ele);
                }

            },

            RenderLatexList: function (latexList) {
                console.log(latexList[4].length)
                console.log(latexList);
                //$(".divider").css("border-top","0px solid white")
                $("#answerLocation").html("Solution:<span id='solvedAnswer'>" + latexList[0][latexList[0].length - 1][0] + "</span>")

                MQ.StaticMath(document.getElementById("solvedAnswer"))

                $("#stepList").empty();

                latexList[0].forEach(function (item, index) {
                    $("#stepList").append("<hr class='stepsHr'>");

                    $("#stepList").append("<div class='step-title'>" + item[1] + "</div>")
                    //$("#stepList").append("<div class='step-title'>Apply Demogan Theorem: <span class='step-data'>\\overline{A+B} = \\overline{A}\\overline{B}</span></div>")
                    $("#stepList").append("<div class='step-data'>" + item[0] + "</div>")
                })

                $("#truthtableLocation").html(latexList[2]);

                var stepdata = document.getElementsByClassName("step-data");
                for (i = 0; i < stepdata.length; i++) {
                    MQ.StaticMath(stepdata[i])
                }


                // Path2d addPath is an experimental feature. Only support on limited browsers.
                var isAddPathSupported = true;

                try {
                    if (latexList[3].length > 0) {

                        var canvas = document.getElementById("kmapCanvas")

                        var kmap = new KMap(latexList[4]);

                        for (var i = 0; i < latexList[3].length; i++) {
                            kmap.addRectangle(latexList[3][i]);
                        }

                        kmap.initAnimation(canvas);
                    }
                } catch (err) {
                    isAddPathSupported = false;

                }

                connectHoverEvents(latexList[1]);

                $("#truthtableContainer").css("display", "block")
                $("#stepContainer").css("display", "block")

                if (latexList[3].length > 0 && isAddPathSupported) {
                    $("#kmapContainer").css("display", "block")
                } else {
                    $("#kmapContainer").css("display", "none")
                }

                if (latexList[5]) {
                    $("#errorLocation").text("WARNING: Solution is not complete. Unable to apply redundancy theorem.");
                } else {
                    $("#errorLocation").text("");
                }

                var originalCircut = getLogicGateDiagram(latexList[6])
                originalCircut.style["max-width"] = "600px"
                var minimalCircut = getLogicGateDiagram(latexList[7])
                minimalCircut.style["max-width"] = "600px"
                $("#minimalView").empty();
                $("#originalView").empty();
                document.getElementById("originalView").appendChild(originalCircut)
                document.getElementById("minimalView").appendChild(minimalCircut)
                $("#logicgateContainer").css("display", "block")

                $("#allConvertBtn").css("display", "block")

                var isBot = /bot|googlebot|crawler|spider|robot|crawling/i.test(navigator.userAgent)
                if (document.getElementById("ad-spot3") && document.getElementById("ad-spot3").children.length == 0 /*&& typeof (window.google_jobrunner) !== "undefined"*/ && !isBot) {
                    var div = document.createElement("div")
                    var script = document.createElement("script");
                    script.async = true;
                    script.src = "https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js";

                    var ins = document.createElement("ins");
                    ins.className = "adsbygoogle";
                    ins.style = "display:block;"
                    ins.setAttribute('data-ad-client', 'ca-pub-3710933901766821');
                    ins.setAttribute('data-ad-slot', '1310713449');
                    ins.setAttribute('data-ad-format', 'auto');
                    ins.setAttribute('data-full-width-responsive', 'true');


                    var script2 = document.createElement("script");
                    script2.text = `(adsbygoogle = window.adsbygoogle || []).push({});`;

                    div.appendChild(script);
                    div.appendChild(ins);
                    div.appendChild(script2);
                    document.getElementById("ad-spot3").appendChild(div)
                }
            },
            RenderLatex: function () {
                var stepdata = document.getElementsByClassName("step-data");
                for (i = 0; i < stepdata.length; i++) {
                    MQ.StaticMath(stepdata[i])
                }
            },
            AddCharToInput: function (char) {
                answerMathField.write(char);
            },
            AddCmdToInput: function (cmd) {
                answerMathField.cmd(cmd);
            },
            MoveCursorLeft: function () {
                answerMathField.keystroke("Left");
            },
            MoveCursorRight: function () {
                answerMathField.keystroke("Right");
            },
            KeyBackspace: function () {
                answerMathField.keystroke("Backspace");
            },
            SetInputText: function (q) {
                answerMathField.latex(q);
                document.getElementById("submit-btn").click();
            },
            Share: function () {
                var sharedQuestion = answerMathField.latex();

                sharedQuestion = sharedQuestion.replace(/\\overline/g, "").replace(/\\left/g, "").replace(/\\right/g, "");
                copyToClipboard("https://www.boolean-algebra.com"+location.pathname+"?q=" + window.btoa(sharedQuestion))

                alert("The url has been copied to your clipboard.");
            },
            ShareKmapUrl: function () {
                if (inputbox.paths.length == 0) {
                    copyToClipboard("https://www.boolean-algebra.com/kmap")
                    alert("The url has been copied to your clipboard.");
                } else {

                    copyToClipboard("https://www.boolean-algebra.com/kmap?q=" + inputbox.saveState())
                    alert("The url has been copied to your clipboard.");
                }
            }
        }



        const copyToClipboard = str => {
            const el = document.createElement('textarea');
            el.value = str;
            el.setAttribute('readonly', '');
            el.style.position = 'absolute';
            el.style.left = '-9999px';
            document.body.appendChild(el);
            el.select();
            document.execCommand('copy');
            document.body.removeChild(el);
        };

        class KMapInput {
            /*<char[]:charSet>
                The characters to be rendered in the corner.
                The order of the array is the order it gets rendered.
                </charSet>*/
            constructor(charSet) {
                this.charSet = charSet;
                this.slotsWidth = 0;
                this.slotsHeight = 0;

                this.paths = []

                this.verticalChars = [];
                this.horizonalChars = [];

                var setList = [...this.charSet]
                this.horizonalChars = setList.splice(Math.ceil(setList.length / 2.0));
                this.verticalChars = setList;

                this.slotsWidth = Math.pow(2, this.horizonalChars.length);
                this.slotsHeight = Math.pow(2, this.verticalChars.length);

                this.eventRef = { clickEvent: null, moveEvent: null, element: null };
            }

            loadGrayCode(grayCode) {
                var sides = grayCode.split('+');
                var x = this.decode(parseInt(sides[0], 2))
                var y = this.decode(parseInt(sides[1], 2))
                this.addRectangle({ x: x, y: y, w: 1, h: 1 })
                console.log(this)
            }

            saveState() {
                var state = `${this.charSet.length}-`
                var codes = []
                this.paths.forEach((path) => {
                    var leftSide = this.encode(path.rawTile.x).toString(2)
                    var rightSide = this.encode(path.rawTile.y).toString(2)

                    var code = leftSide + '+' + rightSide;
                    codes.push(code);

                })
                state += codes.join('_');
                return state;
            }

            forceInput() {
                if (this.onInput) this.onInput(this.paths.map(path => { return { 'x': path.rawTile.x, 'y': path.rawTile.y } }));
            }

            remove() {
                if (this.eventRef.moveEvent) {
                    this.eventRef.element.removeEventListener("mousemove", this.eventRef.moveEvent)
                }

                if (this.eventRef.clickEvent) {
                    this.eventRef.element.removeEventListener("click", this.eventRef.clickEvent)
                }
                this.onInput = null;
                this.eventRef.element.getContext("2d").clearRect(0, 0, this.eventRef.element.width, this.eventRef.element.height);
            }

            initAnimation(canvas) {
                var context = canvas.getContext("2d");
                context.lineWidth = 2;
                this.draw(canvas);

                if (this.eventRef.moveEvent) {
                    this.eventRef.element.removeEventListener("mousemove", this.eventRef.moveEvent)

                }
                if (this.eventRef.clickEvent) {
                    this.eventRef.element.removeEventListener("click", this.eventRef.clickEvent)
                }

                this.eventRef.element = canvas;

                this.eventRef.clickEvent = event => {

                    var pos = this.getMousePos(canvas, event);
                    var xPos = Math.floor((pos.x - 30) / 40) + 1
                    var yPos = Math.floor((pos.y - 30) / 40) + 1
                    if (xPos > this.slotsWidth || yPos > this.slotsHeight || xPos <= 0 || yPos <= 0) return;
                    if (this.paths.some(path => {
                        return path.rawTile.x == xPos && path.rawTile.y == yPos
                    })) {
                        var index = -1;
                        for (var i = 0; i < this.paths.length; i += 1) {
                            if (this.paths[i].rawTile.x === xPos && this.paths[i].rawTile.y === yPos) {
                                index = i;
                                break;
                            }
                        }
                        this.paths.splice(index, 1)
                    } else {
                        this.addRectangle({ x: xPos, y: yPos, w: 1, h: 1 })
                    }
                    if (this.onInput) this.onInput(this.paths.map(path => { return { 'x': path.rawTile.x, 'y': path.rawTile.y } }));
                    this.draw(canvas);
                }

                this.eventRef.moveEvent = event => {
                    context.clearRect(0, 0, canvas.width, canvas.height);
                    this.draw(canvas);

                    //var isSelected = false;f
                    context.save();
                    context.globalAlpha = .5

                    /*var selectedRects = []
                    var pos = this.getMousePos(canvas, event);
                    for (var i = 0; i < this.paths.length; i++) {
                        if (context.isPointInPath(this.paths[i].fill, pos.x, pos.y)) {
                            context.fill(this.paths[i].fill)
                            selectedRects.push(this.paths[i])
                            //isSelected = true;
                        }

                    }*/

                    context.restore();
                }

                canvas.addEventListener('mousemove', this.eventRef.moveEvent);
                canvas.addEventListener('click', this.eventRef.clickEvent);
            }

            /*
            Redraws the canvas with the correct amount of slots

            <int:slotsWidth>
                </slotsWidth>
                <int:slotsHeight>
                    </slotsHeight>
                    */
            draw(canvas) {
                var context = canvas.getContext("2d");

                // clear to redraw the map
                context.clearRect(0, 0, canvas.width, canvas.height);

                // draws main rectangle
                context.beginPath();
                context.rect(30, 30, this.slotsWidth * 40, this.slotsHeight * 40);
                context.stroke();

                // draws \ on top left
                context.beginPath();
                context.moveTo(0, 0);
                context.lineTo(30, 30);
                context.stroke();

                //draw lines --->
                //           --->
                //           --->
                for (var horizonalIndex = 1; horizonalIndex < this.slotsHeight; horizonalIndex++) {
                    context.beginPath();
                    context.moveTo(30, 30 + horizonalIndex * 40);
                    context.lineTo(30 + (this.slotsWidth * 40), 30 + horizonalIndex * 40);
                    context.stroke();
                }

                //draw lines  |  |  |
                //            |  |  |
                //            |  |  |
                for (var verticalIndex = 1; verticalIndex < this.slotsWidth; verticalIndex++) {
                    context.beginPath();
                    context.moveTo(30 + verticalIndex * 40, 30);
                    context.lineTo(30 + verticalIndex * 40, 30 + (this.slotsHeight * 40));
                    context.stroke();
                }


                // draws characters on top left
                context.font = "15px Arial";
                context.textAlign = "center";
                context.save();
                context.font = "15px Arial";
                context.textAlign = "center";
                context.rotate(Math.PI * 2 / (8));
                context.fillText(this.verticalChars.join(''), 25, 15);
                context.fillText(this.horizonalChars.join(''), 25, -3);
                context.restore();

                context.font = "15px Arial";
                for (var i = 0; i < this.slotsWidth; i++) {
                    context.fillText(this.encode(i).toString(2).padStart(this.horizonalChars.length, '0'), i * 40 + 50, 28)
                }

                for (var i = 0; i < this.slotsHeight; i++) {
                    context.fillText(this.encode(i).toString(2).padStart(this.verticalChars.length, '0'), 20, i * 40 + 55)
                }

                for (var i = 0; i < this.paths.length; i++) {
                    context.stroke(this.paths[i].stroke);
                }


            }

            getMousePos(c, evt) {
                var rect = c.getBoundingClientRect();
                return {
                    x: evt.clientX - rect.left,
                    y: evt.clientY - rect.top
                };
            }



            /*
            Converts a tile structure into a path object
            <Tile:tile>
                format:{x,y,w,h}. x,y starts at 1</Tile>
                */
            rectangleToPath(tile) {
                let fillPath = new Path2D();
                let strokePath = new Path2D();

                for (let y = (tile.y - 1) * 2; y < (tile.y - 1 + tile.h) * 2; y++) {
                    for (let x = (tile.x - 1) * 2; x < (tile.x - 1 + tile.w) * 2; x++) {
                        let isStartOfXLoop = (x === (tile.x - 1) * 2);
                        let isStartOfYLoop = (y === (tile.y - 1) * 2);

                        let isEndOfXLoop = x + 1 === (tile.x - 1 + tile.w) * 2;
                        let isEndOfYLoop = y + 1 === (tile.y - 1 + tile.h) * 2;

                        let realX = ((x % (this.slotsWidth * 2)) + (this.slotsWidth * 2)) % (this.slotsWidth * 2);
                        let realY = ((y % (this.slotsHeight * 2)) + (this.slotsHeight * 2)) % (this.slotsHeight * 2);

                        //console.log(realX,realY);

                        if (isStartOfXLoop && isStartOfYLoop) {
                            fillPath.addPath(this.buildTopLeft(realX, realY)(true));
                            strokePath.addPath(this.buildTopLeft(realX, realY)(false));
                        } else if (isStartOfYLoop && isEndOfXLoop) {
                            fillPath.addPath(this.buildTopRight(realX, realY)(true));
                            strokePath.addPath(this.buildTopRight(realX, realY)(false));
                        } else if (isEndOfYLoop && isEndOfXLoop) {
                            fillPath.addPath(this.buildBottomRight(realX, realY)(true));
                            strokePath.addPath(this.buildBottomRight(realX, realY)(false));
                        } else if (isStartOfXLoop && isEndOfYLoop) {
                            fillPath.addPath(this.buildBottomLeft(realX, realY)(true));
                            strokePath.addPath(this.buildBottomLeft(realX, realY)(false));
                        } else if (isStartOfXLoop) {
                            fillPath.addPath(this.buildLeftWall(realX, realY)(true));
                            strokePath.addPath(this.buildLeftWall(realX, realY)(false));
                        } else if (isStartOfYLoop) {
                            fillPath.addPath(this.buildTopWall(realX, realY)(true));
                            strokePath.addPath(this.buildTopWall(realX, realY)(false));
                        } else if (isEndOfXLoop) {
                            fillPath.addPath(this.buildRightWall(realX, realY)(true));
                            strokePath.addPath(this.buildRightWall(realX, realY)(false));
                        } else if (isEndOfYLoop) {
                            fillPath.addPath(this.buildBottomWall(realX, realY)(true));
                            strokePath.addPath(this.buildBottomWall(realX, realY)(false));
                        } else {
                            fillPath.addPath(this.buildCenter(realX, realY)(true));
                        }
                    }
                }
                return { stroke: strokePath, fill: fillPath, solution: tile.eq };
            }

            /*
            Converts a tile structure into a path object
            <Tile:tile>
                format:{x,y,w,h}. x,y starts at 1</Tile>
                */
            addRectangle(tile) {

                var path = this.rectangleToPath(tile);
                path.rawTile = tile;
                this.paths.push(path)
            }

            encode(number) {
                return number ^ (number >> 1)
            }

            decode(encodedNumber) {
                let number = encodedNumber

                while (encodedNumber >>= 1) {
                    number ^= encodedNumber
                }

                return number
            }

            buildTopRight(x, y) {

                return function (fill) {
                    let path = new Path2D();
                    path.arc((x * 20) + 30, (y * 20) + 30 + 20, 12, (.5 * Math.PI) * 3, 0);
                    if (fill) {
                        path.lineTo((x * 20) + 30, (y * 20) + 30 + 20)
                    } else {
                        path.moveTo((x * 20) + 30, (y * 20) + 20 + 30)
                    }
                    path.closePath();
                    return path;
                }
            }
            buildBottomRight(x, y) {

                return function (fill) {
                    let path = new Path2D();
                    path.arc((x * 20) + 30, (y * 20) + 30, 12, 0, (.5 * Math.PI));
                    if (fill) {
                        path.lineTo((x * 20) + 30, (y * 20) + 30)
                    } else {
                        path.moveTo((x * 20) + 30, (y * 20) + 30)
                    }
                    path.closePath();
                    return path;
                }
            }
            buildTopLeft(x, y) {

                return function (fill) {
                    let path = new Path2D();
                    path.arc((x * 20) + 30 + 20, (y * 20) + 30 + 20, 12, (.5 * Math.PI) * 2, (.5 * Math.PI) * 3);
                    if (fill) {
                        path.lineTo((x * 20) + 30 + 20, (y * 20) + 30 + 20)
                    } else {
                        path.moveTo((x * 20) + 30 + 20, (y * 20) + 30 + 20)
                    }
                    path.closePath();
                    return path;
                }
            }
            buildBottomLeft(x, y) {

                return function (fill) {
                    let path = new Path2D();
                    path.arc((x * 20) + 30 + 20, (y * 20) + 30, 12, (.5 * Math.PI) * 1, (.5 * Math.PI) * 2);
                    if (fill) {
                        path.lineTo((x * 20) + 30 + 20, (y * 20) + 30)
                    } else {
                        path.moveTo((x * 20) + 30 + 20, (y * 20) + 30)
                    }
                    path.closePath();
                    return path;
                }
            }
            buildLeftWall(x, y) {
                return function (fill) {
                    let path = new Path2D();
                    path.moveTo((x * 20) + 8 + 30, y * 20 + 30)
                    path.lineTo((x * 20) + 8 + 30, (y * 20) + 20 + 30)
                    if (fill) {
                        path.lineTo((x * 20) + 8 + 30 + 12, (y * 20) + 20 + 30)
                        path.lineTo((x * 20) + 8 + 30 + 12, (y * 20) + 20 + 30 - 20)

                    }

                    path.closePath();
                    return path;
                }
            }
            buildRightWall(x, y) {
                return function (fill) {
                    let path = new Path2D();
                    path.moveTo((x * 20) + 30 + 12, y * 20 + 30)
                    path.lineTo((x * 20) + 30 + 12, (y * 20) + 20 + 30)
                    if (fill) {
                        path.lineTo((x * 20) + 30, (y * 20) + 20 + 30)
                        path.lineTo((x * 20) + 30, (y * 20) + 20 + 30 - 20)

                    }

                    path.closePath();
                    return path;

                }
            }
            buildBottomWall(x, y) {
                return function (fill) {
                    let path = new Path2D();
                    path.moveTo(x * 20 + 30, y * 20 + 30 + 12)
                    path.lineTo(x * 20 + 30 + 20, y * 20 + 30 + 12)
                    if (fill) {
                        path.lineTo(x * 20 + 30 + 20, y * 20 + 30);
                        path.lineTo(x * 20 + 30, y * 20 + 30);
                    }
                    path.closePath();
                    return path
                }
            }
            buildTopWall(x, y) {
                return function (fill) {
                    let path = new Path2D();
                    path.moveTo(x * 20 + 30, y * 20 + 30 + 8)
                    path.lineTo(x * 20 + 30 + 20, y * 20 + 30 + 8)
                    if (fill) {
                        path.lineTo(x * 20 + 30 + 20, y * 20 + 30 + 8 + 12)
                        path.lineTo(x * 20 + 30, y * 20 + 30 + 8 + 12)
                    }
                    path.closePath();
                    return path;
                }
            }
            buildCenter(x, y) {
                return function (fill) {
                    let path = new Path2D();
                    if (fill) {
                        path.moveTo(x * 20 + 30, y * 20 + 30)
                        path.rect(x * 20 + 30, y * 20 + 30, 20, 20)
                    }
                    return path;
                }
            }

        }

        class KMap {
            /*<char[]:charSet>
                The characters to be rendered in the corner.
                The order of the array is the order it gets rendered.
                </charSet>*/
            constructor(charSet) {
                this.charSet = charSet;
                this.slotsWidth = 0;
                this.slotsHeight = 0;

                this.paths = []

                this.verticalChars = [];
                this.horizonalChars = [];

                var setList = [...this.charSet]
                this.horizonalChars = setList.splice(Math.ceil(setList.length / 2.0));
                this.verticalChars = setList;

                this.slotsWidth = Math.pow(2, this.horizonalChars.length);
                this.slotsHeight = Math.pow(2, this.verticalChars.length);

                this.eventRef = { event: null, element: null };
            }

            remove() {
                if (this.eventRef.event) {
                    this.eventRef.element.removeEventListener("mousemove", this.eventRef.event)

                }
                this.eventRef.element.getContext("2d").clearRect(0, 0, this.eventRef.element.width, this.eventRef.element.height);
                this.paths = [];
            }

            initAnimation(canvas) {
                var context = canvas.getContext("2d");
                context.lineWidth = 2;
                this.draw(canvas);

                if (this.eventRef.event) {
                    this.eventRef.element.removeEventListener("mousemove", this.eventRef) // TODO: I might have meant this.eventRef.event
                }
                this.eventRef.element = canvas;
                this.eventRef.event = event => {
                    context.clearRect(0, 0, canvas.width, canvas.height);
                    this.draw(canvas);

                    //var isSelected = false;f
                    context.save();
                    context.globalAlpha = .5

                    var selectedRects = []
                    var pos = this.getMousePos(canvas, event);
                    for (var i = 0; i < this.paths.length; i++) {
                        if (context.isPointInPath(this.paths[i].fill, pos.x, pos.y)) {
                            context.fill(this.paths[i].fill)
                            selectedRects.push(this.paths[i])
                            //isSelected = true;
                        }

                    }

                    for (var i = 0; i < selectedRects.length; i++) {
                        var basePos = 30 + (40 * this.slotsWidth)
                        context.textAlign = 'left'
                        context.font = '30px Arial';
                        context.globalAlpha = 1
                        context.fillText(selectedRects[i].solution, basePos + 10, 50 + i * 40)
                    }

                    context.restore();
                }

                canvas.addEventListener('mousemove', this.eventRef.event);

            }

            /*
            Redraws the canvas with the correct amount of slots

            <int:slotsWidth>
                </slotsWidth>
                <int:slotsHeight>
                    </slotsHeight>
                    */
            draw(canvas) {
                var context = canvas.getContext("2d");

                // clear to redraw the map
                context.clearRect(0, 0, canvas.width, canvas.height);

                // draws main rectangle
                context.beginPath();
                context.rect(30, 30, this.slotsWidth * 40, this.slotsHeight * 40);
                context.stroke();

                // draws \ on top left
                context.beginPath();
                context.moveTo(0, 0);
                context.lineTo(30, 30);
                context.stroke();

                //draw lines --->
                //           --->
                //           --->
                for (var horizonalIndex = 1; horizonalIndex < this.slotsHeight; horizonalIndex++) {
                    context.beginPath();
                    context.moveTo(30, 30 + horizonalIndex * 40);
                    context.lineTo(30 + (this.slotsWidth * 40), 30 + horizonalIndex * 40);
                    context.stroke();
                }

                //draw lines  |  |  |
                //            |  |  |
                //            |  |  |
                for (var verticalIndex = 1; verticalIndex < this.slotsWidth; verticalIndex++) {
                    context.beginPath();
                    context.moveTo(30 + verticalIndex * 40, 30);
                    context.lineTo(30 + verticalIndex * 40, 30 + (this.slotsHeight * 40));
                    context.stroke();
                }


                // draws characters on top left
                context.font = "15px Arial";
                context.textAlign = "center";
                context.save();
                context.font = "15px Arial";
                context.textAlign = "center";
                context.rotate(Math.PI * 2 / (8));
                context.fillText(this.verticalChars.join(''), 25, 15);
                context.fillText(this.horizonalChars.join(''), 25, -3);
                context.restore();

                context.font = "15px Arial";
                for (var i = 0; i < this.slotsWidth; i++) {
                    context.fillText(this.encode(i).toString(2).padStart(this.horizonalChars.length, '0'), i * 40 + 50, 28)
                }

                for (var i = 0; i < this.slotsHeight; i++) {
                    context.fillText(this.encode(i).toString(2).padStart(this.verticalChars.length, '0'), 20, i * 40 + 55)
                }

                for (var i = 0; i < this.paths.length; i++) {
                    context.stroke(this.paths[i].stroke);
                }


            }

            getMousePos(c, evt) {
                var rect = c.getBoundingClientRect();
                return {
                    x: evt.clientX - rect.left,
                    y: evt.clientY - rect.top
                };
            }



            /*
            Converts a tile structure into a path object
            <Tile:tile>
                format:{x,y,w,h}. x,y starts at 1</Tile>
                */
            rectangleToPath(tile) {
                let fillPath = new Path2D();
                let strokePath = new Path2D();

                for (let y = (tile.y - 1) * 2; y < (tile.y - 1 + tile.h) * 2; y++) {
                    for (let x = (tile.x - 1) * 2; x < (tile.x - 1 + tile.w) * 2; x++) {
                        let isStartOfXLoop = (x === (tile.x - 1) * 2);
                        let isStartOfYLoop = (y === (tile.y - 1) * 2);

                        let isEndOfXLoop = x + 1 === (tile.x - 1 + tile.w) * 2;
                        let isEndOfYLoop = y + 1 === (tile.y - 1 + tile.h) * 2;

                        let realX = ((x % (this.slotsWidth * 2)) + (this.slotsWidth * 2)) % (this.slotsWidth * 2);
                        let realY = ((y % (this.slotsHeight * 2)) + (this.slotsHeight * 2)) % (this.slotsHeight * 2);

                        //console.log(realX,realY);

                        if (isStartOfXLoop && isStartOfYLoop) {
                            fillPath.addPath(this.buildTopLeft(realX, realY)(true));
                            strokePath.addPath(this.buildTopLeft(realX, realY)(false));
                        } else if (isStartOfYLoop && isEndOfXLoop) {
                            fillPath.addPath(this.buildTopRight(realX, realY)(true));
                            strokePath.addPath(this.buildTopRight(realX, realY)(false));
                        } else if (isEndOfYLoop && isEndOfXLoop) {
                            fillPath.addPath(this.buildBottomRight(realX, realY)(true));
                            strokePath.addPath(this.buildBottomRight(realX, realY)(false));
                        } else if (isStartOfXLoop && isEndOfYLoop) {
                            fillPath.addPath(this.buildBottomLeft(realX, realY)(true));
                            strokePath.addPath(this.buildBottomLeft(realX, realY)(false));
                        } else if (isStartOfXLoop) {
                            fillPath.addPath(this.buildLeftWall(realX, realY)(true));
                            strokePath.addPath(this.buildLeftWall(realX, realY)(false));
                        } else if (isStartOfYLoop) {
                            fillPath.addPath(this.buildTopWall(realX, realY)(true));
                            strokePath.addPath(this.buildTopWall(realX, realY)(false));
                        } else if (isEndOfXLoop) {
                            fillPath.addPath(this.buildRightWall(realX, realY)(true));
                            strokePath.addPath(this.buildRightWall(realX, realY)(false));
                        } else if (isEndOfYLoop) {
                            fillPath.addPath(this.buildBottomWall(realX, realY)(true));
                            strokePath.addPath(this.buildBottomWall(realX, realY)(false));
                        } else {
                            fillPath.addPath(this.buildCenter(realX, realY)(true));
                        }
                    }
                }
                return { stroke: strokePath, fill: fillPath, solution: tile.eq };
            }

            /*
            Converts a tile structure into a path object
            <Tile:tile>
                format:{x,y,w,h}. x,y starts at 1</Tile>
                */
            addRectangle(tile) {
                this.paths.push(this.rectangleToPath(tile))
            }

            encode(number) {
                return number ^ (number >> 1)
            }

            decode(encodedNumber) {
                let number = encodedNumber

                while (encodedNumber >>= 1) {
                    number ^= encodedNumber
                }

                return number
            }

            buildTopRight(x, y) {

                return function (fill) {
                    let path = new Path2D();
                    path.arc((x * 20) + 30, (y * 20) + 30 + 20, 12, (.5 * Math.PI) * 3, 0);
                    if (fill) {
                        path.lineTo((x * 20) + 30, (y * 20) + 30 + 20)
                    } else {
                        path.moveTo((x * 20) + 30, (y * 20) + 20 + 30)
                    }
                    path.closePath();
                    return path;
                }
            }
            buildBottomRight(x, y) {

                return function (fill) {
                    let path = new Path2D();
                    path.arc((x * 20) + 30, (y * 20) + 30, 12, 0, (.5 * Math.PI));
                    if (fill) {
                        path.lineTo((x * 20) + 30, (y * 20) + 30)
                    } else {
                        path.moveTo((x * 20) + 30, (y * 20) + 30)
                    }
                    path.closePath();
                    return path;
                }
            }
            buildTopLeft(x, y) {

                return function (fill) {
                    let path = new Path2D();
                    path.arc((x * 20) + 30 + 20, (y * 20) + 30 + 20, 12, (.5 * Math.PI) * 2, (.5 * Math.PI) * 3);
                    if (fill) {
                        path.lineTo((x * 20) + 30 + 20, (y * 20) + 30 + 20)
                    } else {
                        path.moveTo((x * 20) + 30 + 20, (y * 20) + 30 + 20)
                    }
                    path.closePath();
                    return path;
                }
            }
            buildBottomLeft(x, y) {

                return function (fill) {
                    let path = new Path2D();
                    path.arc((x * 20) + 30 + 20, (y * 20) + 30, 12, (.5 * Math.PI) * 1, (.5 * Math.PI) * 2);
                    if (fill) {
                        path.lineTo((x * 20) + 30 + 20, (y * 20) + 30)
                    } else {
                        path.moveTo((x * 20) + 30 + 20, (y * 20) + 30)
                    }
                    path.closePath();
                    return path;
                }
            }
            buildLeftWall(x, y) {
                return function (fill) {
                    let path = new Path2D();
                    path.moveTo((x * 20) + 8 + 30, y * 20 + 30)
                    path.lineTo((x * 20) + 8 + 30, (y * 20) + 20 + 30)
                    if (fill) {
                        path.lineTo((x * 20) + 8 + 30 + 12, (y * 20) + 20 + 30)
                        path.lineTo((x * 20) + 8 + 30 + 12, (y * 20) + 20 + 30 - 20)

                    }

                    path.closePath();
                    return path;
                }
            }
            buildRightWall(x, y) {
                return function (fill) {
                    let path = new Path2D();
                    path.moveTo((x * 20) + 30 + 12, y * 20 + 30)
                    path.lineTo((x * 20) + 30 + 12, (y * 20) + 20 + 30)
                    if (fill) {
                        path.lineTo((x * 20) + 30, (y * 20) + 20 + 30)
                        path.lineTo((x * 20) + 30, (y * 20) + 20 + 30 - 20)

                    }

                    path.closePath();
                    return path;

                }
            }
            buildBottomWall(x, y) {
                return function (fill) {
                    let path = new Path2D();
                    path.moveTo(x * 20 + 30, y * 20 + 30 + 12)
                    path.lineTo(x * 20 + 30 + 20, y * 20 + 30 + 12)
                    if (fill) {
                        path.lineTo(x * 20 + 30 + 20, y * 20 + 30);
                        path.lineTo(x * 20 + 30, y * 20 + 30);
                    }
                    path.closePath();
                    return path
                }
            }
            buildTopWall(x, y) {
                return function (fill) {
                    let path = new Path2D();
                    path.moveTo(x * 20 + 30, y * 20 + 30 + 8)
                    path.lineTo(x * 20 + 30 + 20, y * 20 + 30 + 8)
                    if (fill) {
                        path.lineTo(x * 20 + 30 + 20, y * 20 + 30 + 8 + 12)
                        path.lineTo(x * 20 + 30, y * 20 + 30 + 8 + 12)
                    }
                    path.closePath();
                    return path;
                }
            }
            buildCenter(x, y) {
                return function (fill) {
                    let path = new Path2D();
                    if (fill) {
                        path.moveTo(x * 20 + 30, y * 20 + 30)
                        path.rect(x * 20 + 30, y * 20 + 30, 20, 20)
                    }
                    return path;
                }
            }

        }


        mobilecheck = function () {
            var check = false;
            (function (a) { if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) check = true; })(navigator.userAgent || navigator.vendor || window.opera);
            return check ? "true" : "false"; // hacky but needed to support invoking.
        };
        function detectIE() {
            var ua = window.navigator.userAgent;

            var msie = ua.indexOf('MSIE ');
            if (msie > 0) {
                // IE 10 or older => return version number
                return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
            }

            var trident = ua.indexOf('Trident/');
            if (trident > 0) {
                // IE 11 => return version number
                var rv = ua.indexOf('rv:');
                return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
            }

            var edge = ua.indexOf('Edge/');
            if (edge > 0) {
                // Edge (IE 12+) => return version number
                return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
            }

            // other browser
            return false;
        }

        if (detectIE()) {
            alert("Internet Explorer is not supported.")
        }

    </script>
</body>
</html>
