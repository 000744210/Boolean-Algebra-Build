<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boolean Algebra Solver</title>
    <meta name="description" content="Boolean Algebra simplifier & solver. Detailed steps, K-Map, Truth table, & Quizes" />
    <base href="/" />
    <link href="css/bootstrap/bootstrap.min.css" rel="stylesheet" />
    <link href="css/site.css" rel="stylesheet" />
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-150354135-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'UA-150354135-1');
    </script>

    <script type="text/javascript">
        window._mNHandle = window._mNHandle || {};
        window._mNHandle.queue = window._mNHandle.queue || [];
        medianet_versionId = "3121199";
    </script>
    <script src="https://contextual.media.net/dmedianet.js?cid=8CUPIA1C1" async="async"></script>
</head>
<body>

    <app>
        <canvas id="loaderCanvas" style="width:200px;height:200px;margin-left:auto;margin-right:auto;display:block"></canvas>
        <h2 style="text-align:center;margin-left:auto;margin-right:auto;display:block">Loading...</h2>
        <script>
            function initCanvasDraw() {
                /** https://www.dwitter.net/d/1385 **/
                /** Ported to normal javascript **/

                var factor = .4; // scale it down to fit on a smaller canvas.
                var canvas = document.getElementById("loaderCanvas");
                var context = canvas.getContext("2d");
                canvas.width = 500;
                canvas.height = 500;
                var start = Date.now();
                context.scale(factor, factor)
                context.strokeStyle = "Black";
                setInterval(function () {
                    // cleaned and slightly modified version of the original.
                    context.clearRect(0, 0, canvas.width / factor, canvas.height / factor);
                    time = (Date.now() - start) / 1000;
                    for (i = 3; i++ < 11;) {
                        a = i * Math.sin(time) / 4;
                        context.beginPath();
                        context.arc(250 / factor, 250 / factor, 40 * i, Math.min(time + a, time + 3 * a), Math.max(time + a, time + 3 * a));
                        context.lineWidth = i * i / 5;
                        context.stroke();
                    }
                }, 1000 / 60);

            }
            initCanvasDraw();
        </script>
    </app>
    <script type="text/javascript">

        atOptionsBottomList = [
            {
                'key': 'aa401f6589ea8ced1b4f53462a4f797c',
                'format': 'iframe',
                'height': 250,
                'width': 300,
                'min-width': 320,
                'params': {}
            },
            {
                'key': 'ebfe6c66c8a7ba4ddd8a045ac0f276ce',
                'format': 'iframe',
                'height': 50,
                'width': 320,
                'min-width': 350,
                'params': {}
            },
            {
                'key': '7ddcc2f0513abf04bc423459526d3ecc',
                'format': 'iframe',
                'height': 60,
                'width': 468,
                'min-width': 500,
                'params': {}
            },
            {
                'key': '6ce9b4b94bc8b7b7bbe3169ed36d81e4',
                'format': 'iframe',
                'height': 90,
                'width': 728,
                'min-width': 750,
                'params': {}
            }
        ]

        socialBarUrl = "//pl16122563.gatetotrustednetwork.com/22/db/2f/22db2febb1be93c17125454a25a94f42.js"

        atOptionsBottomList = atOptionsBottomList.filter(function (a) { return window.innerWidth >= a['min-width'] })
        atOptions = atOptionsBottomList[Math.floor(Math.random() * atOptionsBottomList.length)];

    </script>
    <script type="blazor-boot">
    </script>
    <script src="_framework/blazor.webassembly.js"></script>
    <link rel="stylesheet" href="/mq/mathquill.css" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
    <script src="/mq/mathquill.js"></script>
    <script>


        var MQ = MathQuill.getInterface(2);
        function connectHoverEvents(classes) {
            for (let i = 0; i < classes.length; i++) {
                if (document.getElementsByClassName(classes[i] + "_event").length > 0) {
                    document.getElementsByClassName(classes[i] + "_event")[0].style["cursor"] = 'pointer'
                    document.getElementsByClassName(classes[i] + "_event")[0].addEventListener("mouseover", function () {
                        var classList = document.querySelectorAll('* [class*= "' + classes[i] + '"]:not(.step-head)');
                        Array.from(classList).forEach(function (e) {
                            if (e["style"]) {
                                e.style["color"] = "red";
                                e.style['border-top-color'] = "red";
                            }
                        });
                    });

                    document.getElementsByClassName(classes[i] + "_event")[0].addEventListener("mouseout", function () {
                        var classList = document.querySelectorAll('* [class*= "' + classes[i] + '"]:not(.step-head)');
                        Array.from(classList).forEach(function (e) {
                            if (e["style"]) {
                                e.style["color"] = "#212529";
                                e.style['border-top-color'] = "#212529";
                            }
                        });
                    });
                }
            }
        }
        function getParameterByName(name, url) {
            if (!url) url = window.location.href;
            name = name.replace(/[\[\]]/g, '\\$&');
            var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'),
                results = regex.exec(url);
            if (!results) return null;
            if (!results[2]) return '';
            return decodeURIComponent(results[2]);
        }

        function getCookie(cname) {
            var name = cname + "=";
            var decodedCookie = decodeURIComponent(document.cookie);
            var ca = decodedCookie.split(';');
            for (var i = 0; i < ca.length; i++) {
                var c = ca[i];
                while (c.charAt(0) == ' ') {
                    c = c.substring(1);
                }
                if (c.indexOf(name) == 0) {
                    return c.substring(name.length, c.length);
                }
            }
            return "";
        }

        var isFirstVisit = true;
        var answerMathField = null;
        window.JsFunc = {
            OnPageFirstLoadGlobal: function () {

            },
            OnPageLoadGlobal: function () {
                var ad = `<div id="790464927">
    <script type='text/javascript'>
        try {
            window._mNHandle.queue.push(function (){
                window._mNDetails.loadTag("790464927", "300x250", "790464927");
            });
        }
        catch (error) {}
    <\/script>
</div>`
          

                document.getElementById('ad-spot').innerHTML = ad;
            },
            BooleanAlgebraPageInit: function () {

                var answerSpan = document.getElementById('question');
                answerMathField = MQ.MathField(answerSpan);
                setTimeout(function () {
                    var q = getParameterByName("q");

                    if (q != null && isFirstVisit) {

                        answerMathField.latex(q.replace(/{/g, "\\overline{"))
                        document.getElementById("submit-btn").click();
                    }
                    /*
                    var seenAd = getCookie("seenAd")

                    var isBot = /bot|googlebot|crawler|spider|robot|crawling/i.test(navigator.userAgent)

                    if (isFirstVisit && seenAd == "" && !isBot) {
                        try {
                            if (Math.random() <= 1) {
                                var script = document.createElement("script");
                                script.src = socialBarUrl;
                                document.body.appendChild(script)
                                var d = new Date();
                                document.cookie = "seenAd=true; expires=Thu, 18 Dec " + (d.getFullYear() + 10) + " 12:00:00 UTC";
                            } else if (atOptions) {
                                var ad = document.getElementById("nord-ad");
                                var script = document.createElement("script");

                                script.src = "https://www.displaynetworkcontent.com/" + atOptions.key + "/invoke.js";
                                ad.appendChild(script)
                                *//*ad.addEventListener("click", function () {
window.open("https://go.nordvpn.net/aff_c?offer_id=15&aff_id=52104&url_id=902");
})
setTimeout(function () {

ad.className = ad.className + " slide"

}, 3000)*//*

                                                    setTimeout(function () {

                                                        ad.className = ad.className + " wiggler"

                                                    }, 20000)
                                                }
                                            } catch (e) {
                                                console.log(e);
                                            }
                                        }*/
                    isFirstVisit = false;
                }, 3000)

            },
            BooleanAlgebraSolveClick: function () {
                DotNet.invokeMethodAsync("Boolean-Algebra", "SolveLatex", answerMathField.latex())
            },
            GetQuestion: function () {
                return answerMathField.latex();
            },
            RenderQuizInterface: function () {
                MQ.StaticMath(document.getElementById("quizQuestion"))

                for (var ele of document.getElementsByClassName("quiz-button-latex")) {
                    MQ.StaticMath(ele);
                }

            },

            RenderLatexList: function (latexList) {

                console.log(latexList[4].length)
                console.log(latexList);
                //$(".divider").css("border-top","0px solid white")
                $("#answerLocation").html("Solution:<span id='solvedAnswer'>" + latexList[0][latexList[0].length - 1][0] + "</span>")

                MQ.StaticMath(document.getElementById("solvedAnswer"))

                $("#stepList").empty();

                latexList[0].forEach(function (item, index) {
                    $("#stepList").append("<hr class='stepsHr'>");

                    $("#stepList").append("<div class='step-title'>" + item[1] + "</div>")
                    //$("#stepList").append("<div class='step-title'>Apply Demogan Theorem: <span class='step-data'>\\overline{A+B} = \\overline{A}\\overline{B}</span></div>")
                    $("#stepList").append("<div class='step-data'>" + item[0] + "</div>")
                })

                $("#truthtableLocation").html(latexList[2]);

                var stepdata = document.getElementsByClassName("step-data");
                for (i = 0; i < stepdata.length; i++) {
                    MQ.StaticMath(stepdata[i])
                }


                // Path2d addPath is an experimental feature. Only support on limited browsers.
                var isAddPathSupported = true;

                try {
                    if (latexList[3].length > 0) {

                        var canvas = document.getElementById("kmapCanvas")

                        var kmap = new KMap(latexList[4]);

                        for (var i = 0; i < latexList[3].length; i++) {

                            kmap.addRectangle(latexList[3][i]);
                        }

                        kmap.initAnimation(canvas);
                    }
                } catch (err) {
                    isAddPathSupported = false;

                }

                connectHoverEvents(latexList[1]);

                $("#truthtableContainer").css("display", "block")
                $("#stepContainer").css("display", "block")

                if (latexList[3].length > 0 && isAddPathSupported) {
                    $("#kmapContainer").css("display", "block")
                } else {
                    $("#kmapContainer").css("display", "none")
                }

                if (latexList[5]) {
                    $("#errorLocation").text("WARNING: Solution is not complete. Unable to apply redundancy theorem.");
                } else {
                    $("#errorLocation").text("");
                }
            },
            RenderLatex: function () {
                var stepdata = document.getElementsByClassName("step-data");
                for (i = 0; i < stepdata.length; i++) {
                    MQ.StaticMath(stepdata[i])
                }
            },
            AddCharToInput: function (char) {
                answerMathField.write(char);
            },
            AddCmdToInput: function (cmd) {
                answerMathField.cmd(cmd);
            },
            MoveCursorLeft: function () {
                answerMathField.keystroke("Left");
            },
            MoveCursorRight: function () {
                answerMathField.keystroke("Right");
            },
            KeyBackspace: function () {
                answerMathField.keystroke("Backspace");
            },
            SetInputText: function (q) {
                answerMathField.latex(q);
                document.getElementById("submit-btn").click();
            },
            Share: function () {
                var sharedQuestion = answerMathField.latex();

                sharedQuestion = sharedQuestion.replace(/\\overline/g, "");

                copyToClipboard("https://www.boolean-algebra.com?q=" + sharedQuestion)

                alert("The url has been copied to your clipboard.");
            }
        }

        const copyToClipboard = str => {
            const el = document.createElement('textarea');
            el.value = str;
            el.setAttribute('readonly', '');
            el.style.position = 'absolute';
            el.style.left = '-9999px';
            document.body.appendChild(el);
            el.select();
            document.execCommand('copy');
            document.body.removeChild(el);
        };

        class KMap {
            /*<char[]:charSet>
              The characters to be rendered in the corner.
              The order of the array is the order it gets rendered.
            </charSet>*/
            constructor(charSet) {
                this.charSet = charSet;
                this.slotsWidth = 0;
                this.slotsHeight = 0;

                this.paths = []

                this.verticalChars = [];
                this.horizonalChars = [];

                var setList = this.charSet
                this.horizonalChars = setList.splice(Math.ceil(setList.length / 2.0));
                this.verticalChars = setList;

                this.slotsWidth = Math.pow(2, this.horizonalChars.length);
                this.slotsHeight = Math.pow(2, this.verticalChars.length);

                this.eventRef = { event: null, element: null };
            }

            remove() {
                if (this.eventRef.event) {
                    this.eventRef.element.removeEventListener("mousemove", this.eventRef.event)
                    this.eventRef.element.getContext("2d").clearRect(0, 0, this.eventRef.element.width, this.eventRef.element.height);
                }

            }

            initAnimation(canvas) {
                var context = canvas.getContext("2d");
                context.lineWidth = 2;
                this.draw(canvas);

                if (this.eventRef.event) {
                    this.eventRef.element.removeEventListener("mousemove", this.eventRef)
                }
                this.eventRef.element = canvas;
                this.eventRef.event = event => {
                    context.clearRect(0, 0, canvas.width, canvas.height);
                    this.draw(canvas);

                    //var isSelected = false;f
                    context.save();
                    context.globalAlpha = .5

                    var selectedRects = []
                    var pos = this.getMousePos(canvas, event);
                    for (var i = 0; i < this.paths.length; i++) {
                        if (context.isPointInPath(this.paths[i].fill, pos.x, pos.y)) {
                            context.fill(this.paths[i].fill)
                            selectedRects.push(this.paths[i])
                            //isSelected = true;
                        }

                    }

                    for (var i = 0; i < selectedRects.length; i++) {
                        var basePos = 30 + (40 * this.slotsWidth)
                        context.textAlign = 'left'
                        context.font = '30px Arial';
                        context.globalAlpha = 1
                        context.fillText(selectedRects[i].solution, basePos + 10, 50 + i * 40)
                    }

                    context.restore();
                }

                canvas.addEventListener('mousemove', this.eventRef.event);

            }

            /*
            Redraws the canvas with the correct amount of slots

            <int:slotsWidth></slotsWidth>
            <int:slotsHeight></slotsHeight>
            */
            draw(canvas) {
                var context = canvas.getContext("2d");

                // clear to redraw the map
                context.clearRect(0, 0, canvas.width, canvas.height);

                // draws main rectangle
                context.beginPath();
                context.rect(30, 30, this.slotsWidth * 40, this.slotsHeight * 40);
                context.stroke();

                // draws \ on top left
                context.beginPath();
                context.moveTo(0, 0);
                context.lineTo(30, 30);
                context.stroke();

                //draw lines --->
                //           --->
                //           --->
                for (var horizonalIndex = 1; horizonalIndex < this.slotsHeight; horizonalIndex++) {
                    context.beginPath();
                    context.moveTo(30, 30 + horizonalIndex * 40);
                    context.lineTo(30 + (this.slotsWidth * 40), 30 + horizonalIndex * 40);
                    context.stroke();
                }

                //draw lines  |  |  |
                //            |  |  |
                //            |  |  |
                for (var verticalIndex = 1; verticalIndex < this.slotsWidth; verticalIndex++) {
                    context.beginPath();
                    context.moveTo(30 + verticalIndex * 40, 30);
                    context.lineTo(30 + verticalIndex * 40, 30 + (this.slotsHeight * 40));
                    context.stroke();
                }


                // draws characters on top left
                context.font = "15px Arial";
                context.textAlign = "center";
                context.save();
                context.font = "15px Arial";
                context.textAlign = "center";
                context.rotate(Math.PI * 2 / (8));
                context.fillText(this.verticalChars.join(''), 25, 15);
                context.fillText(this.horizonalChars.join(''), 25, -3);
                context.restore();

                context.font = "15px Arial";
                for (var i = 0; i < this.slotsWidth; i++) {
                    context.fillText(this.encode(i).toString(2).padStart(this.horizonalChars.length, '0'), i * 40 + 50, 28)
                }

                for (var i = 0; i < this.slotsHeight; i++) {
                    context.fillText(this.encode(i).toString(2).padStart(this.verticalChars.length, '0'), 20, i * 40 + 55)
                }

                for (var i = 0; i < this.paths.length; i++) {
                    context.stroke(this.paths[i].stroke);
                }


            }

            getMousePos(c, evt) {
                var rect = c.getBoundingClientRect();
                return {
                    x: evt.clientX - rect.left,
                    y: evt.clientY - rect.top
                };
            }



            /*
            Converts a tile structure into a path object
            <Tile:tile>format:{x,y,w,h}. x,y starts at 1</Tile>
            */
            rectangleToPath(tile) {
                let fillPath = new Path2D();
                let strokePath = new Path2D();

                for (let y = (tile.y - 1) * 2; y < (tile.y - 1 + tile.h) * 2; y++) {
                    for (let x = (tile.x - 1) * 2; x < (tile.x - 1 + tile.w) * 2; x++) {
                        let isStartOfXLoop = (x === (tile.x - 1) * 2);
                        let isStartOfYLoop = (y === (tile.y - 1) * 2);

                        let isEndOfXLoop = x + 1 === (tile.x - 1 + tile.w) * 2;
                        let isEndOfYLoop = y + 1 === (tile.y - 1 + tile.h) * 2;

                        let realX = ((x % (this.slotsWidth * 2)) + (this.slotsWidth * 2)) % (this.slotsWidth * 2);
                        let realY = ((y % (this.slotsHeight * 2)) + (this.slotsHeight * 2)) % (this.slotsHeight * 2);

                        //console.log(realX,realY);

                        if (isStartOfXLoop && isStartOfYLoop) {
                            fillPath.addPath(this.buildTopLeft(realX, realY)(true));
                            strokePath.addPath(this.buildTopLeft(realX, realY)(false));
                        } else if (isStartOfYLoop && isEndOfXLoop) {
                            fillPath.addPath(this.buildTopRight(realX, realY)(true));
                            strokePath.addPath(this.buildTopRight(realX, realY)(false));
                        } else if (isEndOfYLoop && isEndOfXLoop) {
                            fillPath.addPath(this.buildBottomRight(realX, realY)(true));
                            strokePath.addPath(this.buildBottomRight(realX, realY)(false));
                        } else if (isStartOfXLoop && isEndOfYLoop) {
                            fillPath.addPath(this.buildBottomLeft(realX, realY)(true));
                            strokePath.addPath(this.buildBottomLeft(realX, realY)(false));
                        } else if (isStartOfXLoop) {
                            fillPath.addPath(this.buildLeftWall(realX, realY)(true));
                            strokePath.addPath(this.buildLeftWall(realX, realY)(false));
                        } else if (isStartOfYLoop) {
                            fillPath.addPath(this.buildTopWall(realX, realY)(true));
                            strokePath.addPath(this.buildTopWall(realX, realY)(false));
                        } else if (isEndOfXLoop) {
                            fillPath.addPath(this.buildRightWall(realX, realY)(true));
                            strokePath.addPath(this.buildRightWall(realX, realY)(false));
                        } else if (isEndOfYLoop) {
                            fillPath.addPath(this.buildBottomWall(realX, realY)(true));
                            strokePath.addPath(this.buildBottomWall(realX, realY)(false));
                        } else {
                            fillPath.addPath(this.buildCenter(realX, realY)(true));
                        }
                    }
                }
                return { stroke: strokePath, fill: fillPath, solution: tile.eq };
            }

            /*
            Converts a tile structure into a path object
            <Tile:tile>format:{x,y,w,h}. x,y starts at 1</Tile>
            */
            addRectangle(tile) {
                this.paths.push(this.rectangleToPath(tile))
            }

            encode(number) {
                return number ^ (number >> 1)
            }

            decode(encodedNumber) {
                let number = encodedNumber

                while (encodedNumber >>= 1) {
                    number ^= encodedNumber
                }

                return number
            }

            buildTopRight(x, y) {

                return function (fill) {
                    let path = new Path2D();
                    path.arc((x * 20) + 30, (y * 20) + 30 + 20, 12, (.5 * Math.PI) * 3, 0);
                    if (fill) {
                        path.lineTo((x * 20) + 30, (y * 20) + 30 + 20)
                    } else {
                        path.moveTo((x * 20) + 30, (y * 20) + 20 + 30)
                    }
                    path.closePath();
                    return path;
                }
            }
            buildBottomRight(x, y) {

                return function (fill) {
                    let path = new Path2D();
                    path.arc((x * 20) + 30, (y * 20) + 30, 12, 0, (.5 * Math.PI));
                    if (fill) {
                        path.lineTo((x * 20) + 30, (y * 20) + 30)
                    } else {
                        path.moveTo((x * 20) + 30, (y * 20) + 30)
                    }
                    path.closePath();
                    return path;
                }
            }
            buildTopLeft(x, y) {

                return function (fill) {
                    let path = new Path2D();
                    path.arc((x * 20) + 30 + 20, (y * 20) + 30 + 20, 12, (.5 * Math.PI) * 2, (.5 * Math.PI) * 3);
                    if (fill) {
                        path.lineTo((x * 20) + 30 + 20, (y * 20) + 30 + 20)
                    } else {
                        path.moveTo((x * 20) + 30 + 20, (y * 20) + 30 + 20)
                    }
                    path.closePath();
                    return path;
                }
            }
            buildBottomLeft(x, y) {

                return function (fill) {
                    let path = new Path2D();
                    path.arc((x * 20) + 30 + 20, (y * 20) + 30, 12, (.5 * Math.PI) * 1, (.5 * Math.PI) * 2);
                    if (fill) {
                        path.lineTo((x * 20) + 30 + 20, (y * 20) + 30)
                    } else {
                        path.moveTo((x * 20) + 30 + 20, (y * 20) + 30)
                    }
                    path.closePath();
                    return path;
                }
            }
            buildLeftWall(x, y) {
                return function (fill) {
                    let path = new Path2D();
                    path.moveTo((x * 20) + 8 + 30, y * 20 + 30)
                    path.lineTo((x * 20) + 8 + 30, (y * 20) + 20 + 30)
                    if (fill) {
                        path.lineTo((x * 20) + 8 + 30 + 12, (y * 20) + 20 + 30)
                        path.lineTo((x * 20) + 8 + 30 + 12, (y * 20) + 20 + 30 - 20)

                    }

                    path.closePath();
                    return path;
                }
            }
            buildRightWall(x, y) {
                return function (fill) {
                    let path = new Path2D();
                    path.moveTo((x * 20) + 30 + 12, y * 20 + 30)
                    path.lineTo((x * 20) + 30 + 12, (y * 20) + 20 + 30)
                    if (fill) {
                        path.lineTo((x * 20) + 30, (y * 20) + 20 + 30)
                        path.lineTo((x * 20) + 30, (y * 20) + 20 + 30 - 20)

                    }

                    path.closePath();
                    return path;

                }
            }
            buildBottomWall(x, y) {
                return function (fill) {
                    let path = new Path2D();
                    path.moveTo(x * 20 + 30, y * 20 + 30 + 12)
                    path.lineTo(x * 20 + 30 + 20, y * 20 + 30 + 12)
                    if (fill) {
                        path.lineTo(x * 20 + 30 + 20, y * 20 + 30);
                        path.lineTo(x * 20 + 30, y * 20 + 30);
                    }
                    path.closePath();
                    return path
                }
            }
            buildTopWall(x, y) {
                return function (fill) {
                    let path = new Path2D();
                    path.moveTo(x * 20 + 30, y * 20 + 30 + 8)
                    path.lineTo(x * 20 + 30 + 20, y * 20 + 30 + 8)
                    if (fill) {
                        path.lineTo(x * 20 + 30 + 20, y * 20 + 30 + 8 + 12)
                        path.lineTo(x * 20 + 30, y * 20 + 30 + 8 + 12)
                    }
                    path.closePath();
                    return path;
                }
            }
            buildCenter(x, y) {
                return function (fill) {
                    let path = new Path2D();
                    if (fill) {
                        path.moveTo(x * 20 + 30, y * 20 + 30)
                        path.rect(x * 20 + 30, y * 20 + 30, 20, 20)
                    }
                    return path;
                }
            }

        }


        mobilecheck = function () {
            var check = false;
            (function (a) { if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) check = true; })(navigator.userAgent || navigator.vendor || window.opera);
            return check ? "true" : "false"; // hacky but needed to support invoking.
        };
        function detectIE() {
            var ua = window.navigator.userAgent;

            var msie = ua.indexOf('MSIE ');
            if (msie > 0) {
                // IE 10 or older => return version number
                return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
            }

            var trident = ua.indexOf('Trident/');
            if (trident > 0) {
                // IE 11 => return version number
                var rv = ua.indexOf('rv:');
                return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
            }

            var edge = ua.indexOf('Edge/');
            if (edge > 0) {
                // Edge (IE 12+) => return version number
                return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
            }

            // other browser
            return false;
        }

        if (detectIE()) {
            alert("Internet Explorer is not supported.")
        }

    </script>
</body>
</html>
